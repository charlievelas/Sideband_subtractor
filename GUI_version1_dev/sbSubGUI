#include <TGClient.h>
#include <TCanvas.h>
#include <TH1F.h>  // Include header for histograms
#include <TRandom.h>
#include <TGButton.h>
#include <TGFrame.h>
#include <TGComboBox.h>
#include <TRootEmbeddedCanvas.h>
#include <RQ_OBJECT.h>
#include <TFile.h>
#include <TTree.h>
#include <iostream>
#include <string>
#include <TGNumberEntry.h>  // Include for number entry widgets
#include <TGLabel.h>  // Include for label widget

class MyMainFrame {
    RQ_OBJECT("MyMainFrame")
private:
    TGMainFrame         *fMain;
    TRootEmbeddedCanvas *fEcanvas;
    TCanvas             *fCanvas;
    // Discrimnating variable (i'd use "_Disc" but its not neat)
    TGComboBox          *fComboBoxDisc;  // Drop-down list for branch names for discriminating variable
    TGNumberEntry       *fBinsEntryDisc;  // Number of bins input
    TGNumberEntry       *fMinXEntryDisc;  // Minimum X input
    TGNumberEntry       *fMaxXEntryDisc;  // Maximum X input
    TGNumberEntry       *fSigMinInput;   // Min input box
    TGNumberEntry       *fSigMaxInput;   // Max input box
    TGNumberEntry       *fLSBMinInput;   // Min input box
    TGNumberEntry       *fLSBMaxInput;   // Max input box
    TGNumberEntry       *fRSBMinInput;   // Min input box
    TGNumberEntry       *fRSBMaxInput;   // Max input box
    // Control variable
    TGComboBox          *fComboBoxCont;  // Drop-down list for branch names for control variable
    TGNumberEntry       *fBinsEntryCont;  // Number of bins input
    TGNumberEntry       *fMinXEntryCont;  // Minimum X input
    TGNumberEntry       *fMaxXEntryCont;  // Maximum X input
    // Trees and files
    TFile               *fFile1;       // ROOT file pointer
    TTree               *fTree;       // TTree pointer
    Int_t               fSelectedBranchDisc; // Store selected branch index
    Int_t               fSelectedBranchCont; // Store selected branch index
public:
    MyMainFrame(const TGWindow *p, UInt_t w, UInt_t h, const char* filename1);
    virtual ~MyMainFrame();
    void DoDraw();
    void OnSelectDisc(Int_t id);
    void OnSelectCont(Int_t id);
};

MyMainFrame::MyMainFrame(const TGWindow *p, UInt_t w, UInt_t h, const char* filename1) 
    : fSelectedBranchDisc(-1), fSelectedBranchCont(-1) {  // Initialize fSelectedBranchDisc to -1 (no selection initially)

    // Open the ROOT files
    fFile1 = TFile::Open(filename1);
    if (!fFile1 || !fFile1->IsOpen()) {
        Error("MyMainFrame", "Failed to open file 1: %s", filename1);
        return;
    }

    // Get the first TTrees from the files
    fTree = (TTree*)fFile1->Get(fFile1->GetListOfKeys()->At(0)->GetName()); // 'fTree' has remained 'fTree' for the sake of not having to rewrite large parts of later sections
    
    // Create a main frame
    fMain = new TGMainFrame(p, w, h);

    //// Canvas section
    // Create a horizontal frame to hold the canvas and widgets side by side
    TGHorizontalFrame *hframe = new TGHorizontalFrame(fMain, w, h);

    // Create a vertical frame to hold the label and canvas
    TGVerticalFrame *vframe1 = new TGVerticalFrame(hframe);

    // Create canvas widget (on the left)
    fEcanvas = new TRootEmbeddedCanvas("Ecanvas", vframe1, 1400, 700);
    vframe1->AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY, 5, 5, 5, 5)); // Canvas with all margins

    // Split canvas into two pads
    fCanvas = fEcanvas->GetCanvas();
    fCanvas->Divide(2, 1);

    // Add canvas1 to hframe
    hframe->AddFrame(vframe1, new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsTop | kLHintsLeft, 5, 5, 5, 5)); // Vertical frame in the main frame

    // Create a vertical frame to hold the canvas
    TGVerticalFrame *vframe2 = new TGVerticalFrame(hframe);

    // Create a vertical frame for buttons and drop-down list (on the right)
    TGVerticalFrame *vframe = new TGVerticalFrame(hframe, 200, 140);

    //// Widget section
    // Create and add the Exit button at the top (before all other widgets)
    TGTextButton *exit = new TGTextButton(vframe, "&Exit", "gApplication->Terminate(0)");
    vframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a vertical frame for the labels and combo boxes (Branch name and Branch to cut on)
    TGVerticalFrame *comboFrame = new TGVerticalFrame(vframe, 200, 60);

    // Discriminating variable section label
    TGLabel *DiscLabel = new TGLabel(comboFrame, "Discriminating Variable");
    comboFrame->AddFrame(DiscLabel, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // "Choose variable:" label and ComboBox
    TGLabel *branchLabel = new TGLabel(comboFrame, "Choose variable:");
    comboFrame->AddFrame(branchLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

    fComboBoxDisc = new TGComboBox(comboFrame, "Choose variable", 50);
    fComboBoxDisc->Select(1); // Default selection (1)
    fComboBoxDisc->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectDisc(Int_t)");
    fComboBoxDisc->Resize(200, 25);
    comboFrame->AddFrame(fComboBoxDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(comboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a horizontal frame for the three input boxes (Bins, Min x, Max x)
    TGHorizontalFrame *hInputFrame = new TGHorizontalFrame(vframe, 200, 120);

    // Bins label and input box
    TGVerticalFrame *binsFrame = new TGVerticalFrame(hInputFrame, 60, 60);
    TGLabel *binsLabel = new TGLabel(binsFrame, "Bins:");
    binsFrame->AddFrame(binsLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fBinsEntryDisc = new TGNumberEntry(binsFrame, 100, 5, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber);
    fBinsEntryDisc->SetWidth(60);
    binsFrame->AddFrame(fBinsEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame->AddFrame(binsFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Min x label and input box
    TGVerticalFrame *minXFrame = new TGVerticalFrame(hInputFrame, 60, 60);
    TGLabel *minXLabel = new TGLabel(minXFrame, "Min x:");
    minXFrame->AddFrame(minXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fMinXEntryDisc = new TGNumberEntry(minXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fMinXEntryDisc->SetWidth(60);
    minXFrame->AddFrame(fMinXEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame->AddFrame(minXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Max x label and input box
    TGVerticalFrame *maxXFrame = new TGVerticalFrame(hInputFrame, 60, 60);
    TGLabel *maxXLabel = new TGLabel(maxXFrame, "Max x:");
    maxXFrame->AddFrame(maxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fMaxXEntryDisc = new TGNumberEntry(maxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fMaxXEntryDisc->SetWidth(60);
    maxXFrame->AddFrame(fMaxXEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame->AddFrame(maxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(hInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a horizontal frame for the signal region inputs
    TGHorizontalFrame *hSigInputFrame = new TGHorizontalFrame(vframe, 200, 120);

    // Signal min x label and input box
    TGVerticalFrame *SigMinXFrame = new TGVerticalFrame(hSigInputFrame, 60, 60);
    TGLabel *SigMinXLabel = new TGLabel(SigMinXFrame, "Min x:");
    SigMinXFrame->AddFrame(SigMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fSigMinInput = new TGNumberEntry(SigMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fSigMinInput->SetWidth(60);
    SigMinXFrame->AddFrame(fSigMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hSigInputFrame->AddFrame(SigMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Max x label and input box
    TGVerticalFrame *SigMaxXFrame = new TGVerticalFrame(hSigInputFrame, 60, 60);
    TGLabel *SigMaxXLabel = new TGLabel(SigMaxXFrame, "Max x:");
    SigMaxXFrame->AddFrame(SigMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fSigMaxInput = new TGNumberEntry(SigMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fSigMaxInput->SetWidth(60);
    SigMaxXFrame->AddFrame(fSigMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hSigInputFrame->AddFrame(SigMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(hSigInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a horizontal frame for the left sideband inputs
    TGHorizontalFrame *hLSBInputFrame = new TGHorizontalFrame(vframe, 200, 120);

    // Left sideband min x label and input box
    TGVerticalFrame *LSBMinXFrame = new TGVerticalFrame(hLSBInputFrame, 60, 60);
    TGLabel *LSBMinXLabel = new TGLabel(LSBMinXFrame, "Min x:");
    LSBMinXFrame->AddFrame(LSBMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fLSBMinInput = new TGNumberEntry(LSBMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fLSBMinInput->SetWidth(60);
    LSBMinXFrame->AddFrame(fLSBMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hLSBInputFrame->AddFrame(LSBMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Left sideband max x label and input box
    TGVerticalFrame *LSBMaxXFrame = new TGVerticalFrame(hLSBInputFrame, 60, 60);
    TGLabel *LSBMaxXLabel = new TGLabel(LSBMaxXFrame, "Max x:");
    LSBMaxXFrame->AddFrame(LSBMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fLSBMaxInput = new TGNumberEntry(LSBMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fLSBMaxInput->SetWidth(60);
    LSBMaxXFrame->AddFrame(fLSBMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hLSBInputFrame->AddFrame(LSBMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(hLSBInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a horizontal frame for the right sideband inputs
    TGHorizontalFrame *hRSBInputFrame = new TGHorizontalFrame(vframe, 200, 120);

    // Right sideband min x label and input box
    TGVerticalFrame *RSBMinXFrame = new TGVerticalFrame(hRSBInputFrame, 60, 60);
    TGLabel *RSBMinXLabel = new TGLabel(RSBMinXFrame, "Min x:");
    RSBMinXFrame->AddFrame(RSBMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fRSBMinInput = new TGNumberEntry(RSBMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fRSBMinInput->SetWidth(60);
    RSBMinXFrame->AddFrame(fRSBMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hRSBInputFrame->AddFrame(RSBMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Right sideband max x label and input box
    TGVerticalFrame *RSBMaxXFrame = new TGVerticalFrame(hRSBInputFrame, 60, 60);
    TGLabel *RSBMaxXLabel = new TGLabel(RSBMaxXFrame, "Max x:");
    RSBMaxXFrame->AddFrame(RSBMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fRSBMaxInput = new TGNumberEntry(RSBMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fRSBMaxInput->SetWidth(60);
    RSBMaxXFrame->AddFrame(fRSBMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hRSBInputFrame->AddFrame(RSBMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(hRSBInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // horizontal line, figure out how to do

    // Create a vertical frame for the labels and combo boxes (Branch name and Branch to cut on)
    TGVerticalFrame *comboFrame2 = new TGVerticalFrame(vframe, 200, 60);

    // Discriminating variable section label
    TGLabel *ContLabel = new TGLabel(comboFrame2, "Discriminating Variable");
    comboFrame2->AddFrame(ContLabel, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // "Choose variable:" label and ComboBox
    TGLabel *branchLabel2 = new TGLabel(comboFrame2, "Choose variable:");
    comboFrame2->AddFrame(branchLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

    fComboBoxCont = new TGComboBox(comboFrame2, "Choose variable", 50);
    fComboBoxCont->Select(1); // Default selection (1)
    fComboBoxCont->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCont(Int_t)");
    fComboBoxCont->Resize(200, 25);
    comboFrame2->AddFrame(fComboBoxCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(comboFrame2, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

    // Create a horizontal frame for the three input boxes (Bins, Min x, Max x)
    TGHorizontalFrame *hInputFrame2 = new TGHorizontalFrame(vframe, 200, 120);

    // Bins label and input box
    TGVerticalFrame *binsFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
    TGLabel *binsLabel2 = new TGLabel(binsFrame2, "Bins:");
    binsFrame2->AddFrame(binsLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fBinsEntryCont = new TGNumberEntry(binsFrame2, 100, 5, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber);
    fBinsEntryCont->SetWidth(60);
    binsFrame2->AddFrame(fBinsEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame2->AddFrame(binsFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Min x label and input box
    TGVerticalFrame *minXFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
    TGLabel *minXLabel2 = new TGLabel(minXFrame2, "Min x:");
    minXFrame2->AddFrame(minXLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fMinXEntryCont = new TGNumberEntry(minXFrame2, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fMinXEntryCont->SetWidth(60);
    minXFrame2->AddFrame(fMinXEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame2->AddFrame(minXFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    // Max x label and input box
    TGVerticalFrame *maxXFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
    TGLabel *maxXLabel2 = new TGLabel(maxXFrame2, "Max x:");
    maxXFrame2->AddFrame(maxXLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
    fMaxXEntryCont = new TGNumberEntry(maxXFrame2, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
    fMaxXEntryCont->SetWidth(60);
    maxXFrame2->AddFrame(fMaxXEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
    hInputFrame2->AddFrame(maxXFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

    vframe->AddFrame(hInputFrame2, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));
    
    // Add the Draw button
    TGTextButton *draw = new TGTextButton(vframe, "&Draw");
    draw->Connect("Clicked()", "MyMainFrame", this, "DoDraw()"); 
    vframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX, 10, 5, 10, 5));

    hframe->AddFrame(vframe, new TGLayoutHints(kLHintsCenterY, 2, 2, 2, 2));

    fMain->AddFrame(hframe, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));

    // Set a name to the main frame
    fMain->SetWindowName("TTree Branch Selector");

    // Populate the ComboBoxes with branch names
    if (fTree) {
       TObjArray *branches = fTree->GetListOfBranches();
       for (int i = 0; i < branches->GetEntries(); i++) {
          TBranch *branch = (TBranch*)branches->At(i);
          fComboBoxCont->AddEntry(branch->GetName(), i+1); // Add branches to ComboBox (index + 1)
          fComboBoxDisc->AddEntry(branch->GetName(), i+1); // Add branches to ComboBox (index + 1)
       }
    }

    // Map all subwindows of main frame
    fMain->MapSubwindows();

    // Initialize the layout algorithm
    fMain->Resize(fMain->GetDefaultSize());

    // Map main frame
    fMain->MapWindow();

}


void MyMainFrame::DoDraw() {

   // Retrieve the selected branch from the first combo box (branch to draw)
   if (fSelectedBranchDisc == -1) {
      Error("DoDraw", "Error: No discriminating variable selected.");
      return;
   }
   if (fSelectedBranchCont == -1) {
      Error("DoDraw", "Error: No control variable selected.");
      return;
   }
   
   // Get the branch corresponding to the selected option
   TBranch *branchDisc = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchDisc - 1); // fSelectedBranchDisc is 1-based
   if (!branchDisc) {
      Error("DoDraw", "Invalid selection.");
      return;
   }
   string branchNameDisc = branchDisc->GetName();   
   TBranch *branchCont = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchCont - 1); // fSelectedBranchCont is 1-based
   if (!branchCont) {
      Error("DoDraw", "Invalid selection.");
      return;
   }
   string branchNameCont = branchCont->GetName();

   // Retrieve the number of bins, min and max X values from the input boxes
   Int_t fBinsDisc = fBinsEntryDisc->GetNumber();
   Double_t fMinXDisc = fMinXEntryDisc->GetNumber();
   Double_t fMaxXDisc = fMaxXEntryDisc->GetNumber();
   Double_t fSigMin = fSigMinInput->GetNumber();
   Double_t fSigMax = fSigMaxInput->GetNumber();
   Double_t fLSBMin = fLSBMinInput->GetNumber();
   Double_t fLSBMax = fLSBMaxInput->GetNumber();
   Double_t fRSBMin = fRSBMinInput->GetNumber();
   Double_t fRSBMax = fRSBMaxInput->GetNumber();

   Int_t fBinsCont = fBinsEntryCont->GetNumber();
   Double_t fMinXCont = fMinXEntryCont->GetNumber();
   Double_t fMaxXCont = fMaxXEntryCont->GetNumber();

   // Draw strings
   TString drawCommandDisc = "";
   TString drawTitleDisc = "Discriminating variable: ";

   TString drawCommandCont = "";
   TString drawTitleCont = "Control variable: ";

   drawCommandDisc = TString::Format("%s>>hist1(%d,%f,%f)", branchNameDisc.c_str(), fBinsDisc, fMinXDisc, fMaxXDisc);
   drawTitleDisc += branchNameDisc.c_str();

   drawCommandCont = TString::Format("%s>>hist2(%d,%f,%f)", branchNameCont.c_str(), fBinsCont, fMinXCont, fMaxXCont);
   drawTitleCont += branchNameCont.c_str();

   // Output print
   std::cout << "////////  Drawn with following  ////////" << std::endl;
   std::cout << "Discriminating variable: " << drawCommandDisc.Data() << std::endl;
   std::cout << "Control variable: " << drawCommandCont.Data() << std::endl;

   // Clear each pad before drawing new histograms
   // Extended comment: The method below works because histograms being initliasied 
   // and assigned for each branch on the tree rather than drawing the tree straight 
   // to the canvas, this allows for interactivity of both graphs after they are plotted.
   fCanvas->Clear();  // Clear the canvas to reset any changes
   fCanvas->Divide(2, 1);  // Restore original pad layout (2 pads side-by-side)
   
   fCanvas->cd(1);
   gPad->Clear();

   fCanvas->cd(2);
   gPad->Clear();

   // Defining and drawing first tree histogram
   fTree->Draw(drawCommandDisc.Data());
   TH1F *hist1a = (TH1F*)gDirectory->Get("hist1");
   hist1a->SetTitle(drawTitleDisc.Data());
   hist1a->SetStats(0);
   fCanvas->cd(1);
   hist1a->Draw();

   // Defining and drawing second tree histogram
   fTree->Draw(drawCommandCont.Data());
   TH1F *hist2a = (TH1F*)gDirectory->Get("hist2");
   hist2a->SetTitle(drawTitleCont.Data());
   fCanvas->cd(2);
   hist2a->Draw();

   // Update the canvas to display the histograms
   fCanvas->Update();

}


void MyMainFrame::OnSelectDisc(Int_t id) {
   fSelectedBranchDisc = id;

}

void MyMainFrame::OnSelectCont(Int_t id) {
   fSelectedBranchCont = id;
}


MyMainFrame::~MyMainFrame() {
   // Clean up used widgets: frames, buttons, layout hints
   fMain->Cleanup();
   delete fMain;
   if (fFile1) {
      fFile1->Close();
      delete fFile1;
   }
}

void sbSubGUI(const char* filename1) {
   // Popup the GUI with the given ROOT file...
   new MyMainFrame(gClient->GetRoot(), 1400, 700, filename1);
}
