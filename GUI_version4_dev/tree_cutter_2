void tree_cutter(string infile_1, string infile_2){

    // Open file and get tree and branches
    const char *infile_name_1 = infile_1.c_str();

    TFile f_1(infile_name_1);

    TTree *tree_1 = (TTree*)f_1.Get(f_1.GetListOfKeys()->At(0)->GetName());

    // Create a map to store the branch names and the corresponding data pointers
    std::map<std::string, void*> branches;
    std::map<std::string, std::string> branchTypes;

    // Get the list of branches in the tree
    TObjArray* branchList = tree_1->GetListOfBranches();

    // Loop through all branches and set the addresses dynamically
    for (int i = 0; i < branchList->GetEntries(); i++) {
        TBranch* branch = (TBranch*)branchList->At(i);
        std::string branchName = branch->GetName();
        //cout << "branch: " << branchName << endl;

        // Get type of the branch using the leaf type
        const char* branchType = branch->GetLeaf(branchName.c_str())->GetTypeName();
        std::string branchType_str = branchType;

        // Checking the type of the branch by name or some other criteria
        if (branchType_str == "Int_t" || branchType_str == "int") {
            int* branchValue = new int;
            branches[branchName] = (void*)branchValue;
            branchTypes[branchName] = "int";
            tree_1->SetBranchAddress(branchName.c_str(), branchValue);
        } else if (branchType_str == "Double_t" || branchType_str == "double") {
            double* branchValue = new double;
            branches[branchName] = (void*)branchValue;
            branchTypes[branchName] = "double";
            tree_1->SetBranchAddress(branchName.c_str(), branchValue);
        } else if (branchType_str == "Float_t" || branchType_str == "float") {
            float* branchValue = new float;
            branches[branchName] = (void*)branchValue;
            branchTypes[branchName] = "float";
            tree_1->SetBranchAddress(branchName.c_str(), branchValue);
        } else if (branchType_str == "String_t" || branchType_str == "string") {
            string* branchValue = new string;
            branches[branchName] = (void*)branchValue;
            branchTypes[branchName] = "string";
            tree_1->SetBranchAddress(branchName.c_str(), branchValue);
        }
    }

    // Make new file and tree
    const char *infile_name_2 = infile_2.c_str();

    TFile f_2(infile_name_2,"recreate");

    TTree *newTree = tree_1->CloneTree(0);  // Clone the tree with zero entries


    // Loop section
    Long64_t nentries = tree_1->GetEntries(); // read the number of entries in the t3
    for (Long64_t i = 0; i < nentries; i++) {
        // Get event
        tree_1->GetEvent(i);   

        // Selecting specific branches using format below
        /*~~~~~~~~~~~~~~~~~~~~~
        auto brNUMBER = branches.find("NAME");
        double NAME;
        if (brNUMBER != branches.end()) {
            // Access the data from the map (cast brNUMBER to the correct type)
            double* data_NAME = static_cast<double*>(brNUMBER->second);
            NAME = (double)*data_NAME;
        }
        ~~~~~~~~~~~~~~~~~~~~~*/
        auto br0 = branches.find("Electron_P");
        double Electron_P;
        if (br0 != branches.end()) {
            double* data_Electron_P = static_cast<double*>(br0->second);
            Electron_P = (double)*data_Electron_P;
        }
        auto br1 = branches.find("kpkmMissMass2");
        double kpkmMissMass2;
        if (br1 != branches.end()) {
            double* data_kpkmMissMass2 = static_cast<double*>(br1->second);
            kpkmMissMass2 = (double)*data_kpkmMissMass2;
        }
        auto br2 = branches.find("Electron_Th");
        double Electron_Th;
        if (br2 != branches.end()) {
            double* data_Electron_Th = static_cast<double*>(br2->second);
            Electron_Th = (double)*data_Electron_Th;
        }
        auto br3 = branches.find("Kaonp_Th");
        double Kaonp_Th;
        if (br3 != branches.end()) {
            double* data_Kaonp_Th = static_cast<double*>(br3->second);
            Kaonp_Th = (double)*data_Kaonp_Th;
        }
        auto br4 = branches.find("Kaonm_Th");
        double Kaonm_Th;
        if (br4 != branches.end()) {
            double* data_Kaonm_Th = static_cast<double*>(br4->second);
            Kaonm_Th = (double)*data_Kaonm_Th;
        }
        auto br5 = branches.find("kpkmMissMassPKp");
        double kpkmMissMassPKp;
        if (br5 != branches.end()) {
            double* data_kpkmMissMassPKp = static_cast<double*>(br5->second);
            kpkmMissMassPKp = (double)*data_kpkmMissMassPKp;
        }
        auto br6 = branches.find("kpkmMissMassPKm");
        double kpkmMissMassPKm;
        if (br6 != branches.end()) {
            double* data_kpkmMissMassPKm = static_cast<double*>(br6->second);
            kpkmMissMassPKm = (double)*data_kpkmMissMassPKm;
        }

        
        // Electron energy
        double el_E;
        el_E=sqrt(pow(Electron_P,2)+pow(0.000511,2));
        //// CONDITIONS //// (currently output 6)
        if (abs(kpkmMissMass2)<0.01 && el_E>0.4 && el_E<5 && Electron_Th>0.035 && Electron_Th<0.087 && Kaonp_Th<0.61 && Kaonm_Th<0.61 && kpkmMissMassPKp>0.0 && kpkmMissMassPKm>0.0 && kpkmMissMassPKp<0.8 && kpkmMissMassPKm<0.8){
            newTree->Fill();
        }
        
    }

    newTree->Write("", TObject::kOverwrite); // save only the new version of the tree
    f_1.Close();
}
