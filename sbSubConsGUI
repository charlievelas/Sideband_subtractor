#include <TGClient.h>
#include <TCanvas.h>
#include <TH1F.h>  // Include header for histograms
#include <TRandom.h>
#include <TGButton.h>
#include <TGFrame.h>
#include <TGComboBox.h>
#include <TRootEmbeddedCanvas.h>
#include <RQ_OBJECT.h>
#include <TFile.h>
#include <TTree.h>
#include <iostream>
#include <string>
#include <TGNumberEntry.h>  // Include for number entry widgets
#include <TGLabel.h>  // Include for label widget

// Fit functions
// Background - Quadratic background function
double Background(double *x, double *par) {
   return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];
}
// Signal - Gauss Peak function
double GaussPeak(double *x, double *par) {
   return par[0]*TMath::Gaus(x[0], par[1], par[2]);
}
// Sum of background and peak function
double fitFunction(double *x, double *par) {
   return Background(x,par) + GaussPeak(x,&par[3]);
   //&par[5] is where the guass parameters start in the length-8 'par' array containing the parameters for the background and the peak
}

class MyMainFrame {
   RQ_OBJECT("MyMainFrame")
private:
   TGMainFrame         *fMain;
   TRootEmbeddedCanvas *fEcanvas;
   TCanvas             *fCanvas;
   // Discrimnating variable (i'd use "_Disc" but its not neat)
   TGComboBox          *fComboBoxDisc;  // Drop-down list for branch names for discriminating variable
   TGNumberEntry       *fBinsEntryDisc;  // Number of bins input
   TGNumberEntry       *fMinXEntryDisc;  // Minimum X input
   TGNumberEntry       *fMaxXEntryDisc;  // Maximum X input
   TGNumberEntry       *fSigMinInput;   // Min input box
   TGNumberEntry       *fSigMaxInput;   // Max input box
   TGNumberEntry       *fFitMinInput;   // Min input box
   TGNumberEntry       *fFitMaxInput;   // Max input box
   TGNumberEntry       *fLSBMinInput;   // Min input box
   TGNumberEntry       *fLSBMaxInput;   // Max input box
   TGNumberEntry       *fRSBMinInput;   // Min input box
   TGNumberEntry       *fRSBMaxInput;   // Max input box
   // Control variable
   TGComboBox          *fComboBoxCont;  // Drop-down list for branch names for control variable
   TGNumberEntry       *fBinsEntryCont;  // Number of bins input
   TGNumberEntry       *fMinXEntryCont;  // Minimum X input for drawing
   TGNumberEntry       *fMaxXEntryCont;  // Maximum X input for drawing
   TGNumberEntry       *fSubMinInput;  // Minimum X input for subtraction
   TGNumberEntry       *fSubMaxInput;  // Maximum X input for subtraction
   // Control variable - conditions
   TGComboBox          *fCon1ComboBox; // Drop-down list for condition 1
   TGComboBox          *fCon2ComboBox; // Drop-down list for condition 2
   TGComboBox          *fCon3ComboBox; // Drop-down list for condition 3
   TGComboBox          *fCon4ComboBox; // Drop-down list for condition 4   
   TGNumberEntry       *fCon1MinInput;   // Min input box for condition 1
   TGNumberEntry       *fCon1MaxInput;   // Max input box for condition 1
   TGNumberEntry       *fCon2MinInput;   // Min input box for condition 2
   TGNumberEntry       *fCon2MaxInput;   // Max input box for condition 2
   TGNumberEntry       *fCon3MinInput;   // Min input box for condition 3
   TGNumberEntry       *fCon3MaxInput;   // Max input box for condition 3
   TGNumberEntry       *fCon4MinInput;   // Min input box for condition 4
   TGNumberEntry       *fCon4MaxInput;   // Max input box for condition 4
   // Trees and files
   TFile               *fFile1;       // ROOT file pointer
   TTree               *fTree;       // TTree pointer
   Int_t               fSelectedBranchDisc; // Store selected branch index
   Int_t               fSelectedBranchCont; // Store selected branch index
public:
   MyMainFrame(const TGWindow *p, UInt_t w, UInt_t h, const char* filename1);
   virtual ~MyMainFrame();
   void DoDraw();
   void DoFit();
   void DoSub();
   void OnSelectDisc(Int_t id);
   void OnSelectCont(Int_t id);
   //void OnSelectCon1(Int_t id);
   //void OnSelectCon2(Int_t id);
   //void OnSelectCon3(Int_t id);
   //void OnSelectCon4(Int_t id);
};

MyMainFrame::MyMainFrame(const TGWindow *p, UInt_t w, UInt_t h, const char* filename1) 
   : fSelectedBranchDisc(-1), fSelectedBranchCont(-1) {  // Initialize fSelectedBranchDisc to -1 (no selection initially)

   // Open the ROOT files
   fFile1 = TFile::Open(filename1);
   if (!fFile1 || !fFile1->IsOpen()) {
      Error("MyMainFrame", "Failed to open file 1: %s", filename1);
      return;
   }

   // Get the first TTrees from the files
   fTree = (TTree*)fFile1->Get(fFile1->GetListOfKeys()->At(0)->GetName()); // 'fTree' has remained 'fTree' for the sake of not having to rewrite large parts of later sections
    
   // Create a main frame
   fMain = new TGMainFrame(p, w, h);

   //// Canvas section
   // Create a horizontal frame to hold the canvas and widgets side by side
   TGHorizontalFrame *hframe = new TGHorizontalFrame(fMain, w, h);

   //// Left widgets

   // Create a vertical frame for dsicriminating variable widgets on the left
   TGVerticalFrame *vframeL = new TGVerticalFrame(hframe, 200, 140);

   //// Widget section
   // Create and add the Exit button at the top (before all other widgets)
   TGTextButton *exit = new TGTextButton(vframeL, "&Exit", "gApplication->Terminate(0)");
   vframeL->AddFrame(exit, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Add a 3D horizontal line 
   TGHorizontal3DLine *hline1 = new TGHorizontal3DLine(vframeL);
   hline1->Resize(200, 1);  // Resize the line to be longer, 300px wide and 1px tall
   vframeL->AddFrame(hline1, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a vertical frame for the labels and combo boxes (Branch name and Branch to cut on)
   TGVerticalFrame *comboFrame = new TGVerticalFrame(vframeL, 200, 60);

   // Discriminating variable section label
   TGLabel *DiscLabel = new TGLabel(comboFrame, "Discriminating Variable");
   comboFrame->AddFrame(DiscLabel, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 5));

   // "Choose variable:" label and ComboBox
   TGLabel *branchLabel = new TGLabel(comboFrame, "Choose variable:");
   comboFrame->AddFrame(branchLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fComboBoxDisc = new TGComboBox(comboFrame, "Choose variable", 50);
   fComboBoxDisc->Select(1); // Default selection (1)
   fComboBoxDisc->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectDisc(Int_t)");
   fComboBoxDisc->Resize(200, 25);
   comboFrame->AddFrame(fComboBoxDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeL->AddFrame(comboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a horizontal frame for the bin input box
   TGHorizontalFrame *hBinsInputFrame = new TGHorizontalFrame(vframeL, 200, 120);

   // Bins label and input box
   TGHorizontalFrame *binsFrame = new TGHorizontalFrame(hBinsInputFrame, 60, 60);
   TGLabel *binsLabel = new TGLabel(binsFrame, "Bins:");
   binsFrame->AddFrame(binsLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fBinsEntryDisc = new TGNumberEntry(binsFrame, 100, 5, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber);
   fBinsEntryDisc->SetWidth(60);
   binsFrame->AddFrame(fBinsEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hBinsInputFrame->AddFrame(binsFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeL->AddFrame(hBinsInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));   

   // Create a horizontal frame for the bin input box
   TGHorizontalFrame *hInputFrame = new TGHorizontalFrame(vframeL, 200, 120);

   // Min x label and input box
   TGVerticalFrame *minXFrame = new TGVerticalFrame(hInputFrame, 60, 60);
   TGLabel *minXLabel = new TGLabel(minXFrame, "Min x:");
   minXFrame->AddFrame(minXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fMinXEntryDisc = new TGNumberEntry(minXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fMinXEntryDisc->SetWidth(60);
   minXFrame->AddFrame(fMinXEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hInputFrame->AddFrame(minXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Max x label and input box
   TGVerticalFrame *maxXFrame = new TGVerticalFrame(hInputFrame, 60, 60);
   TGLabel *maxXLabel = new TGLabel(maxXFrame, "Max x:");
   maxXFrame->AddFrame(maxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fMaxXEntryDisc = new TGNumberEntry(maxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fMaxXEntryDisc->SetWidth(60);
   maxXFrame->AddFrame(fMaxXEntryDisc, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hInputFrame->AddFrame(maxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeL->AddFrame(hInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a horizontal frame for the fit range inputs
   TGHorizontalFrame *hFitLabelFrame = new TGHorizontalFrame(vframeL, 200, 60);
   TGLabel *FitLabel = new TGLabel(hFitLabelFrame, "Fit range:");
   hFitLabelFrame->AddFrame(FitLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));
   vframeL->AddFrame(hFitLabelFrame, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));

   TGHorizontalFrame *hFitInputFrame = new TGHorizontalFrame(vframeL, 200, 60);

   // Fit range min x label and input box
   TGVerticalFrame *FitMinXFrame = new TGVerticalFrame(hFitInputFrame, 120, 60);
   TGLabel *FitMinXLabel = new TGLabel(FitMinXFrame, "Min:");
   FitMinXFrame->AddFrame(FitMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fFitMinInput = new TGNumberEntry(FitMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fFitMinInput->SetWidth(60);
   FitMinXFrame->AddFrame(fFitMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hFitInputFrame->AddFrame(FitMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Max x label and input box
   TGVerticalFrame *FitMaxXFrame = new TGVerticalFrame(hFitInputFrame, 120, 60);
   TGLabel *FitMaxXLabel = new TGLabel(FitMaxXFrame, "Max:");
   FitMaxXFrame->AddFrame(FitMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fFitMaxInput = new TGNumberEntry(FitMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fFitMaxInput->SetWidth(60);
   FitMaxXFrame->AddFrame(fFitMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hFitInputFrame->AddFrame(FitMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeL->AddFrame(hFitInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Create a horizontal frame for the signal region inputs
   TGHorizontalFrame *hSigLabelFrame = new TGHorizontalFrame(vframeL, 200, 60);
   TGLabel *SigLabel = new TGLabel(hSigLabelFrame, "Signal region:");
   hSigLabelFrame->AddFrame(SigLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));
   vframeL->AddFrame(hSigLabelFrame, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));

   TGHorizontalFrame *hSigInputFrame = new TGHorizontalFrame(vframeL, 200, 60);

   // Signal min x label and input box
   TGVerticalFrame *SigMinXFrame = new TGVerticalFrame(hSigInputFrame, 120, 60);
   TGLabel *SigMinXLabel = new TGLabel(SigMinXFrame, "Min:");
   SigMinXFrame->AddFrame(SigMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fSigMinInput = new TGNumberEntry(SigMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fSigMinInput->SetWidth(60);
   SigMinXFrame->AddFrame(fSigMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hSigInputFrame->AddFrame(SigMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Max x label and input box
   TGVerticalFrame *SigMaxXFrame = new TGVerticalFrame(hSigInputFrame, 120, 60);
   TGLabel *SigMaxXLabel = new TGLabel(SigMaxXFrame, "Max:");
   SigMaxXFrame->AddFrame(SigMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fSigMaxInput = new TGNumberEntry(SigMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fSigMaxInput->SetWidth(60);
   SigMaxXFrame->AddFrame(fSigMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hSigInputFrame->AddFrame(SigMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeL->AddFrame(hSigInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Create a horizontal frame for the left sideband inputs
   TGHorizontalFrame *hSBLabelFrame = new TGHorizontalFrame(vframeL, 200, 60);
   TGLabel *SBLabel = new TGLabel(hSBLabelFrame, "Sideband regions:");
   hSBLabelFrame->AddFrame(SBLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));
   vframeL->AddFrame(hSBLabelFrame, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));

   TGHorizontalFrame *hLSBInputFrame = new TGHorizontalFrame(vframeL, 200, 120);

   // Left sideband min x label and input box
   TGVerticalFrame *LSBMinXFrame = new TGVerticalFrame(hLSBInputFrame, 60, 60);
   TGLabel *LSBMinXLabel = new TGLabel(LSBMinXFrame, "L Min:");
   LSBMinXFrame->AddFrame(LSBMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fLSBMinInput = new TGNumberEntry(LSBMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fLSBMinInput->SetWidth(60);
   LSBMinXFrame->AddFrame(fLSBMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hLSBInputFrame->AddFrame(LSBMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Left sideband max x label and input box
   TGVerticalFrame *LSBMaxXFrame = new TGVerticalFrame(hLSBInputFrame, 60, 60);
   TGLabel *LSBMaxXLabel = new TGLabel(LSBMaxXFrame, "L Max:");
   LSBMaxXFrame->AddFrame(LSBMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fLSBMaxInput = new TGNumberEntry(LSBMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fLSBMaxInput->SetWidth(60);
   LSBMaxXFrame->AddFrame(fLSBMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hLSBInputFrame->AddFrame(LSBMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeL->AddFrame(hLSBInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Create a horizontal frame for the right sideband inputs
   TGHorizontalFrame *hRSBInputFrame = new TGHorizontalFrame(vframeL, 200, 120);

   // Right sideband min x label and input box
   TGVerticalFrame *RSBMinXFrame = new TGVerticalFrame(hRSBInputFrame, 60, 60);
   TGLabel *RSBMinXLabel = new TGLabel(RSBMinXFrame, "R Min");
   RSBMinXFrame->AddFrame(RSBMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fRSBMinInput = new TGNumberEntry(RSBMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fRSBMinInput->SetWidth(60);
   RSBMinXFrame->AddFrame(fRSBMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hRSBInputFrame->AddFrame(RSBMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Right sideband max x label and input box
   TGVerticalFrame *RSBMaxXFrame = new TGVerticalFrame(hRSBInputFrame, 60, 60);
   TGLabel *RSBMaxXLabel = new TGLabel(RSBMaxXFrame, "R Max:");
   RSBMaxXFrame->AddFrame(RSBMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fRSBMaxInput = new TGNumberEntry(RSBMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fRSBMaxInput->SetWidth(60);
   RSBMaxXFrame->AddFrame(fRSBMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hRSBInputFrame->AddFrame(RSBMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeL->AddFrame(hRSBInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   hframe->AddFrame(vframeL, new TGLayoutHints(kLHintsLeft, 2, 2, 2, 2));

   //// Canvas
   // Create a vertical frame to hold the label and canvas
   TGVerticalFrame *vframe1 = new TGVerticalFrame(hframe);

   // Create canvas widget (on the left)
   fEcanvas = new TRootEmbeddedCanvas("Ecanvas", vframe1, 1400, 700);
   vframe1->AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY, 5, 5, 5, 5)); // Canvas with all margins

   // Split canvas into two pads
   fCanvas = fEcanvas->GetCanvas();
   fCanvas->Divide(2, 1);

   // Add canvas1 to hframe
   hframe->AddFrame(vframe1, new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsTop | kLHintsLeft, 5, 5, 5, 5)); // Vertical frame in the main frame

   //// Right widgets
   // Create a vertical frame for control variable widgets on the right
   TGVerticalFrame *vframeR = new TGVerticalFrame(hframe, 200, 140);

   // Create a vertical frame for the labels and combo boxes (Branch name and Branch to cut on)
   TGVerticalFrame *comboFrame2 = new TGVerticalFrame(vframeR, 200, 60);

   // Discriminating variable section label
   TGLabel *ContLabel = new TGLabel(comboFrame2, "Control Variable");
   comboFrame2->AddFrame(ContLabel, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 5));

   // "Choose variable:" label and ComboBox
   TGLabel *branchLabel2 = new TGLabel(comboFrame2, "Choose variable:");
   comboFrame2->AddFrame(branchLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fComboBoxCont = new TGComboBox(comboFrame2, "Choose variable", 50);
   fComboBoxCont->Select(1); // Default selection (1)
   fComboBoxCont->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCont(Int_t)");
   fComboBoxCont->Resize(200, 25);
   comboFrame2->AddFrame(fComboBoxCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeR->AddFrame(comboFrame2, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a horizontal frame for the three input boxes (Bins, Min x, Max x)
   TGHorizontalFrame *hInputFrame2 = new TGHorizontalFrame(vframeR, 200, 120);

   // Bins label and input box
   TGVerticalFrame *binsFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
   TGLabel *binsLabel2 = new TGLabel(binsFrame2, "Bins:");
   binsFrame2->AddFrame(binsLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fBinsEntryCont = new TGNumberEntry(binsFrame2, 100, 5, -1, TGNumberFormat::kNESInteger, TGNumberFormat::kNEAAnyNumber);
   fBinsEntryCont->SetWidth(60);
   binsFrame2->AddFrame(fBinsEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hInputFrame2->AddFrame(binsFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Min x label and input box
   TGVerticalFrame *minXFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
   TGLabel *minXLabel2 = new TGLabel(minXFrame2, "Min");
   minXFrame2->AddFrame(minXLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fMinXEntryCont = new TGNumberEntry(minXFrame2, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fMinXEntryCont->SetWidth(60);
   minXFrame2->AddFrame(fMinXEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hInputFrame2->AddFrame(minXFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Max x label and input box
   TGVerticalFrame *maxXFrame2 = new TGVerticalFrame(hInputFrame2, 60, 60);
   TGLabel *maxXLabel2 = new TGLabel(maxXFrame2, "Max");
   maxXFrame2->AddFrame(maxXLabel2, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));
   fMaxXEntryCont = new TGNumberEntry(maxXFrame2, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fMaxXEntryCont->SetWidth(60);
   maxXFrame2->AddFrame(fMaxXEntryCont, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));
   hInputFrame2->AddFrame(maxXFrame2, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeR->AddFrame(hInputFrame2, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a horizontal frame for the subtraction region inputs
   TGHorizontalFrame *hSubLabelFrame = new TGHorizontalFrame(vframeR, 200, 60);
   TGLabel *SubLabel = new TGLabel(hSubLabelFrame, "Subtraction range:");
   hSubLabelFrame->AddFrame(SubLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));
   vframeR->AddFrame(hSubLabelFrame, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 0));

   TGHorizontalFrame *hSubInputFrame = new TGHorizontalFrame(vframeR, 200, 60);

   // Subtraction min x label and input box
   TGHorizontalFrame *SubMinXFrame = new TGHorizontalFrame(hSubInputFrame, 120, 60);
   TGLabel *SubMinXLabel = new TGLabel(SubMinXFrame, "Min:");
   SubMinXFrame->AddFrame(SubMinXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fSubMinInput = new TGNumberEntry(SubMinXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fSubMinInput->SetWidth(60);
   SubMinXFrame->AddFrame(fSubMinInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hSubInputFrame->AddFrame(SubMinXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Max x label and input box
   TGHorizontalFrame *SubMaxXFrame = new TGHorizontalFrame(hSubInputFrame, 120, 60);
   TGLabel *SubMaxXLabel = new TGLabel(SubMaxXFrame, "Max:");
   SubMaxXFrame->AddFrame(SubMaxXLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));
   fSubMaxInput = new TGNumberEntry(SubMaxXFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fSubMaxInput->SetWidth(60);
   SubMaxXFrame->AddFrame(fSubMaxInput, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));
   hSubInputFrame->AddFrame(SubMaxXFrame, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeR->AddFrame(hSubInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   //// Right widgets - conditions
   // Add a 3D horizontal line
   TGHorizontal3DLine *hline3 = new TGHorizontal3DLine(vframeR);
   hline3->Resize(200, 1);  // Resize the line to be longer, 300px wide and 1px tall
   vframeR->AddFrame(hline3, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   //// Condition 1
   // Condition 1 frame
   TGVerticalFrame *Con1ComboFrame = new TGVerticalFrame(vframeR, 200, 60);

   // Condition 1 label and ComboBox
   TGLabel *Con1Label = new TGLabel(Con1ComboFrame, "Condition 1:");
   Con1ComboFrame->AddFrame(Con1Label, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fCon1ComboBox = new TGComboBox(Con1ComboFrame, "Select branch", 50);
   fCon1ComboBox->Select(1); // Default selection (1)
   //fCon1ComboBox->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCon1(Int_t)");
   fCon1ComboBox->Resize(200, 25);
   Con1ComboFrame->AddFrame(fCon1ComboBox, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   vframeR->AddFrame(Con1ComboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));

   // Create a horizontal frame for the Min and Max labels and input boxes
   TGHorizontalFrame *Con1MinMaxFrame = new TGHorizontalFrame(vframeR, 200, 60);

   // Min label
   TGLabel *Con1MinLabel = new TGLabel(Con1MinMaxFrame, "Min");
   Con1MinMaxFrame->AddFrame(Con1MinLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Min input box (float)
   fCon1MinInput = new TGNumberEntry(Con1MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon1MinInput->SetWidth(60);
   Con1MinMaxFrame->AddFrame(fCon1MinInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max label
   TGLabel *Con1MaxLabel = new TGLabel(Con1MinMaxFrame, "Max");
   Con1MinMaxFrame->AddFrame(Con1MaxLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max input box (float)
   fCon1MaxInput = new TGNumberEntry(Con1MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon1MaxInput->SetWidth(60);
   Con1MinMaxFrame->AddFrame(fCon1MaxInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   vframeR->AddFrame(Con1MinMaxFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   //// Condition 2
   // Condition 2 frame
   TGVerticalFrame *Con2ComboFrame = new TGVerticalFrame(vframeR, 200, 60);

   // Condition 2 label
   TGLabel *Con2Label = new TGLabel(Con2ComboFrame, "Condition 2:");
   Con2ComboFrame->AddFrame(Con2Label, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fCon2ComboBox = new TGComboBox(Con2ComboFrame, "Select branch", 50);
   fCon2ComboBox->Select(1); // Default selection (1)
   //fCon2ComboBox->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCon2(Int_t)");
   fCon2ComboBox->Resize(200, 25);
   Con2ComboFrame->AddFrame(fCon2ComboBox, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Second condition min/max inputs
   TGHorizontalFrame *Con2MinMaxFrame = new TGHorizontalFrame(Con2ComboFrame, 200, 60);
   TGLabel *Con2MinLabel = new TGLabel(Con2MinMaxFrame, "Min");
   Con2MinMaxFrame->AddFrame(Con2MinLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   fCon2MinInput = new TGNumberEntry(Con2MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon2MinInput->SetWidth(60);
   Con2MinMaxFrame->AddFrame(fCon2MinInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   TGLabel *Con2MaxLabel = new TGLabel(Con2MinMaxFrame, "Max");
   Con2MinMaxFrame->AddFrame(Con2MaxLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   fCon2MaxInput = new TGNumberEntry(Con2MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon2MaxInput->SetWidth(60);
   Con2MinMaxFrame->AddFrame(fCon2MaxInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   Con2ComboFrame->AddFrame(Con2MinMaxFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   vframeR->AddFrame(Con2ComboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   //// Condition 2
   // Condition 3 frame
   TGVerticalFrame *Con3ComboFrame = new TGVerticalFrame(vframeR, 200, 100);

   // Condition 3 label and ComboBox
   TGLabel *Con3Label = new TGLabel(Con3ComboFrame, "Condition 3:");
   Con3ComboFrame->AddFrame(Con3Label, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fCon3ComboBox = new TGComboBox(Con3ComboFrame, "Select branch", 50);
   fCon3ComboBox->Select(1); // Default selection (1)
   //fCon3ComboBox->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCon2(Int_t)");
   fCon3ComboBox->Resize(200, 25);
   Con3ComboFrame->AddFrame(fCon3ComboBox, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Create a horizontal frame for the min/max input boxes
   TGHorizontalFrame *Con3MinMaxFrame = new TGHorizontalFrame(Con3ComboFrame, 200, 60);

   // Min label
   TGLabel *Con3MinLabel = new TGLabel(Con3MinMaxFrame, "Min");
   Con3MinMaxFrame->AddFrame(Con3MinLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Min input box (float)
   fCon3MinInput = new TGNumberEntry(Con3MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon3MinInput->SetWidth(60);
   Con3MinMaxFrame->AddFrame(fCon3MinInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max label
   TGLabel *Con3MaxLabel = new TGLabel(Con3MinMaxFrame, "Max");
   Con3MinMaxFrame->AddFrame(Con3MaxLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max input box (float)
   fCon3MaxInput = new TGNumberEntry(Con3MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon3MaxInput->SetWidth(60);
   Con3MinMaxFrame->AddFrame(fCon3MaxInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Add the min/max input frame to the main frame
   Con3ComboFrame->AddFrame(Con3MinMaxFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Add the new frame to the main vertical frame (vframeR)
   vframeR->AddFrame(Con3ComboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   //// Condition 4
   // Condition 4 frame
   TGVerticalFrame *Con4ComboFrame = new TGVerticalFrame(vframeR, 200, 100);

   // Condition 4 label and ComboBox
   TGLabel *Con4Label = new TGLabel(Con4ComboFrame, "Condition 4:");
   Con4ComboFrame->AddFrame(Con4Label, new TGLayoutHints(kLHintsLeft, 5, 5, 3, 4));

   fCon4ComboBox = new TGComboBox(Con4ComboFrame, "Select branch", 50);
   fCon4ComboBox->Select(1); // Default selection (1)
   //fCon4ComboBox->Connect("Selected(Int_t)", "MyMainFrame", this, "OnSelectCon4(Int_t)");
   fCon4ComboBox->Resize(200, 25);
   Con4ComboFrame->AddFrame(fCon4ComboBox, new TGLayoutHints(kLHintsCenterY, 5, 5, 3, 4));

   // Create a horizontal frame for the min/max input boxes
   TGHorizontalFrame *Con4MinMaxFrame = new TGHorizontalFrame(Con4ComboFrame, 200, 60);

   // Min label
   TGLabel *Con4MinLabel = new TGLabel(Con4MinMaxFrame, "Min");
   Con4MinMaxFrame->AddFrame(Con4MinLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Min input box (float)
   fCon4MinInput = new TGNumberEntry(Con4MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon4MinInput->SetWidth(60);
   Con4MinMaxFrame->AddFrame(fCon4MinInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max label
   TGLabel *Con4MaxLabel = new TGLabel(Con4MinMaxFrame, "Max");
   Con4MinMaxFrame->AddFrame(Con4MaxLabel, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Max input box (float)
   fCon4MaxInput = new TGNumberEntry(Con4MinMaxFrame, 0, 5, -1, TGNumberFormat::kNESReal, TGNumberFormat::kNEAAnyNumber);
   fCon4MaxInput->SetWidth(60);
   Con4MinMaxFrame->AddFrame(fCon4MaxInput, new TGLayoutHints(kLHintsLeft, 5, 5, 5, 5));

   // Add the min/max input frame to the main frame
   Con4ComboFrame->AddFrame(Con4MinMaxFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Add the new frame to the main vertical frame (vframeR)
   vframeR->AddFrame(Con4ComboFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));

   // Add a 3D horizontal line
   TGHorizontal3DLine *hline4 = new TGHorizontal3DLine(vframeR);
   hline4->Resize(200, 1);  // Resize the line to be longer, 300px wide and 1px tall
   vframeR->AddFrame(hline4, new TGLayoutHints(kLHintsCenterX, 5, 5, 3, 4));
   
   // Final buttons
   TGHorizontalFrame *hButsInputFrame = new TGHorizontalFrame(vframeR, 200, 60);

   // Add the Draw button
   TGTextButton *draw = new TGTextButton(hButsInputFrame, "&Draw");
   draw->SetMargins(10, 10, 7, 7);
   draw->Connect("Clicked()", "MyMainFrame", this, "DoDraw()");
   hButsInputFrame->AddFrame(draw, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5)); 

   // Add the fit button
   TGTextButton *fit = new TGTextButton(hButsInputFrame, "&Fit");
   fit->SetMargins(10, 10, 7, 7);
   fit->Connect("Clicked()", "MyMainFrame", this, "DoFit()");
   hButsInputFrame->AddFrame(fit, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   // Add the subtract button
   TGTextButton *sub = new TGTextButton(hButsInputFrame, "&Subtract");
   sub->SetMargins(10, 10, 7, 7);
   sub->Connect("Clicked()", "MyMainFrame", this, "DoSub()");
   hButsInputFrame->AddFrame(sub, new TGLayoutHints(kLHintsCenterY, 5, 5, 5, 5));

   vframeR->AddFrame(hButsInputFrame, new TGLayoutHints(kLHintsCenterX, 5, 5, 5, 5));
   
   // Add to main frame
   hframe->AddFrame(vframeR, new TGLayoutHints(kLHintsRight, 2, 2, 2, 2));
   fMain->AddFrame(hframe, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));

   // Set a name to the main frame
   fMain->SetWindowName("Sideband Subtractor");

   // Add "None" to all condition combo boxes
   fCon1ComboBox->AddEntry("None", 0);
   fCon2ComboBox->AddEntry("None", 0);
   fCon3ComboBox->AddEntry("None", 0);
   fCon4ComboBox->AddEntry("None", 0);

   // Populate the ComboBoxes with branch names
   if (fTree) {
      TObjArray *branches = fTree->GetListOfBranches();
      for (int i = 0; i < branches->GetEntries(); i++) {
         TBranch *branch = (TBranch*)branches->At(i);
         fComboBoxDisc->AddEntry(branch->GetName(), i+1); // Add branches to ComboBoxDisc (index + 1)
         fComboBoxCont->AddEntry(branch->GetName(), i+1); // Add branches to ComboBoxCont (index + 1)
         fCon1ComboBox->AddEntry(branch->GetName(), i+1); // Add branches to Con1ComboBox (index + 1)
         fCon2ComboBox->AddEntry(branch->GetName(), i+1); // Add branches to Con2ComboBox (index + 1)
         fCon3ComboBox->AddEntry(branch->GetName(), i+1); // Add branches to Con3ComboBox (index + 1)
         fCon4ComboBox->AddEntry(branch->GetName(), i+1); // Add branches to Con4ComboBox (index + 1)
      }
   }

   // Map all subwindows of main frame
   fMain->MapSubwindows();

   // Initialize the layout algorithm
   fMain->Resize(fMain->GetDefaultSize());

   // Map main frame
   fMain->MapWindow();

}


void MyMainFrame::DoDraw() {

   // Retrieve the selected branch from the first combo box (branch to draw)
   if (fSelectedBranchDisc == -1) {
      Error("DoDraw", "Error: No discriminating variable selected.");
      return;
   }
   if (fSelectedBranchCont == -1) {
      Error("DoDraw", "Error: No control variable selected.");
      return;
   }
   
   // Get the branch corresponding to the selected option
   TBranch *branchDisc = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchDisc - 1); // fSelectedBranchDisc is 1-based
   if (!branchDisc) {
      Error("DoDraw", "Invalid selection.");
      return;
   }
   string branchNameDisc = branchDisc->GetName();   
   TBranch *branchCont = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchCont - 1); // fSelectedBranchCont is 1-based
   if (!branchCont) {
      Error("DoDraw", "Invalid selection.");
      return;
   }
   string branchNameCont = branchCont->GetName();

   // Retrieve the number of bins, min and max X values from the input boxes
   Int_t fBinsDisc = fBinsEntryDisc->GetNumber();
   Double_t fMinXDisc = fMinXEntryDisc->GetNumber();
   Double_t fMaxXDisc = fMaxXEntryDisc->GetNumber();
   
   Int_t fBinsCont = fBinsEntryCont->GetNumber();
   Double_t fMinXCont = fMinXEntryCont->GetNumber();
   Double_t fMaxXCont = fMaxXEntryCont->GetNumber();

   // Set all input boxes to zero
   fSigMinInput->SetNumber(0);
   fSigMaxInput->SetNumber(0);
   fFitMinInput->SetNumber(0);
   fFitMaxInput->SetNumber(0);
   fLSBMinInput->SetNumber(0);
   fLSBMaxInput->SetNumber(0);
   fRSBMinInput->SetNumber(0);
   fRSBMaxInput->SetNumber(0);

   // Draw strings
   TString drawCommandDisc = "";
   TString drawTitleDisc = "Discriminating variable: ";

   TString drawCommandCont = "";
   TString drawTitleCont = "Control variable: ";

   drawCommandDisc = TString::Format("%s>>hist1(%d,%f,%f)", branchNameDisc.c_str(), fBinsDisc, fMinXDisc, fMaxXDisc);
   drawTitleDisc += branchNameDisc.c_str();

   drawCommandCont = TString::Format("%s>>hist2(%d,%f,%f)", branchNameCont.c_str(), fBinsCont, fMinXCont, fMaxXCont);
   drawTitleCont += branchNameCont.c_str();

   TString drawCondition = "";

   // Apply condition 1
   Int_t Con1Index = fCon1ComboBox->GetSelected();
   if (Con1Index > 0) {
      TBranch *Con1Branch = (TBranch*)fTree->GetListOfBranches()->At(Con1Index - 1);
      Double_t Con1Min = fCon1MinInput->GetNumber();
      Double_t Con1Max = fCon1MaxInput->GetNumber();
      drawCondition += Form("%s > %.10g && %s < %.10g", Con1Branch->GetName(), Con1Min, Con1Branch->GetName(), Con1Max);
      drawTitleCont += Form(", %s[%.10g,%.10g]",Con1Branch->GetName(), Con1Min, Con1Max);  
   }

   // Print all draw strings
   std::cout << "////////  Drawn with following  ////////" << std::endl;
   std::cout << "Discriminating variable: " << drawCommandDisc.Data() << std::endl;
   std::cout << "Control variable: " << drawCommandCont.Data() << std::endl;
   std::cout << "Conditions: " << drawCondition.Data() << std::endl;

   // Clear each pad before drawing new histograms
   // Extended comment: The method below works because histograms being initliasied 
   // and assigned for each branch on the tree rather than drawing the tree straight 
   // to the canvas, this allows for interactivity of both graphs after they are plotted.
   fCanvas->Clear();  // Clear the canvas to reset any changes
   fCanvas->Divide(2, 1);  // Restore original pad layout (2 pads side-by-side)
   
   fCanvas->cd(1);
   gPad->Clear();

   // Defining and drawing first tree histogram
   fTree->Draw(drawCommandDisc.Data());
   TH1F *histDisc = (TH1F*)gDirectory->Get("hist1");
   histDisc->SetTitle(drawTitleDisc.Data());
   histDisc->SetStats(0);
   fCanvas->cd(1);
   histDisc->Draw("hist");
   histDisc->SetMinimum(0);

   fCanvas->cd(2);
   gPad->Clear();

   // Pad 2
   // Defining and drawing second tree histogram
   fTree->Draw(drawCommandCont.Data(),drawCondition);
   TH1F *histCont = (TH1F*)gDirectory->Get("hist2");
   fCanvas->cd(2);
   histCont->Draw();
   histCont->SetTitle(drawTitleCont.Data());
   histCont->SetMinimum(0);

   // Update the canvas to display the histograms
   fCanvas->Update();

}

void MyMainFrame::DoFit() {

   // Retrieve the selected branch from the first combo box (branch to draw)
   if (fSelectedBranchDisc == -1) {
      Error("DoFit", "Error: No discriminating variable selected.");
      return;
   }
   if (fSelectedBranchCont == -1) {
      Error("DoFit", "Error: No control variable selected.");
      return;
   }
   
   // Get the branch corresponding to the selected option
   TBranch *branchDisc = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchDisc - 1); // fSelectedBranchDisc is 1-based
   if (!branchDisc) {
      Error("DoFit", "Invalid selection.");
      return;
   }
   string branchNameDisc = branchDisc->GetName();   
   TBranch *branchCont = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchCont - 1); // fSelectedBranchCont is 1-based
   if (!branchCont) {
      Error("DoFit", "Invalid selection.");
      return;
   }
   string branchNameCont = branchCont->GetName();

   // Retrieve the number of bins, min and max X values from the input boxes
   Int_t fBinsDisc = fBinsEntryDisc->GetNumber();
   Double_t fMinXDisc = fMinXEntryDisc->GetNumber();
   Double_t fMaxXDisc = fMaxXEntryDisc->GetNumber();
   Double_t fFitMin = fFitMinInput->GetNumber();
   Double_t fFitMax = fFitMaxInput->GetNumber();
   Double_t fSigMin = fSigMinInput->GetNumber();
   Double_t fSigMax = fSigMaxInput->GetNumber();
   Double_t fLSBMin = fLSBMinInput->GetNumber();
   Double_t fLSBMax = fLSBMaxInput->GetNumber();
   Double_t fRSBMin = fRSBMinInput->GetNumber();
   Double_t fRSBMax = fRSBMaxInput->GetNumber();

   Int_t fBinsCont = fBinsEntryCont->GetNumber();
   Double_t fMinXCont = fMinXEntryCont->GetNumber();
   Double_t fMaxXCont = fMaxXEntryCont->GetNumber();
   Double_t fSubMin = fSubMinInput->GetNumber();
   Double_t fSubMax = fSubMaxInput->GetNumber();

   // Introducting autofit, a function that fits the discriminating variable using the total (poly+gauss) fit function
   //                       for a given discriminating variable range (only requirement)
   // Autofit is activated when disc range given and all other variables are zero (using differences might not work in some cases)
   // Autofit fails when there no peaks or when two or more peaks are found.
   // Note: consider autofit button at some point

   int autofit_check = 0;

   //// Checks
   // Total failure check - if all variables or all differences zero, fail
   if (fMaxXDisc==0 && fMinXDisc==0 && fFitMax==0 && fFitMin==0 && fSigMax==0 && fSigMin==0 && fLSBMax==0 && fLSBMin==0 && fRSBMax==0 && fRSBMin==0){
      Error("DoFit", "Error: All variables are zero.\nChoose a discriminating variable range and fit to activate Autofit.");
      return;
   }
   if (fMaxXDisc-fMinXDisc==0 && fFitMax-fFitMin==0 && fSigMax-fSigMin==0 && fLSBMax-fLSBMin==0 && fRSBMax-fRSBMin==0){
      Error("DoFit", "Error: All ranges are zero.\nChoose a non-zero discriminating variable range and fit to activate Autofit.");
      return;
   }
   // Discriminating variable range check - if discriminating variable range is zero, fail
   if (fMaxXDisc-fMinXDisc==0){
      Error("DoFit", "Error: Discriminating variable range must be provided.");
         return;
   }
   // Autofit check - if discrimnating variable range is non-zero and all other variables are zero, activate autofit
   if (fMaxXDisc-fMinXDisc!=0 && fFitMax==0 && fFitMin==0 && fSigMax==0 && fSigMin==0 && fLSBMax==0 && fLSBMin==0 && fRSBMax==0 && fRSBMin==0){
      cout << "Autofit activated (discrimnating variable range provided and all other variables zero)." << endl;
      autofit_check++;
   }

   // User variable failure - if all variables are non-zero but at least one has a difference of zero, fail 
   if (fMaxXDisc-fMinXDisc!=0 && autofit_check==0){
      // Fit range check
      if (fFitMax-fFitMin==0) {
         Error("DoFit", "Error: Fit range is zero.");
         return;
      }
      // Signal region check
      if (fSigMax-fSigMin==0) {
         Error("DoFit", "Error: Signal region range is zero.");
         return;
      }
      // Left sideband check
      if (fLSBMax-fLSBMin==0) {
         Error("DoFit", "Error: Left sideband range is zero.");
         return;
      }
      // Right sideband check
      if (fRSBMax-fRSBMin==0) {
         Error("DoFit", "Error: Right sideband range is zero.");
         return;
      }
   }

   // Sideband-signal check - if sideband and signal overlap or if signal not between sidebands, fail
   if (fLSBMax>fSigMin || fRSBMin<fSigMax && autofit_check==0){
      Error("DoFit", "Error: Sideband-signal overlap or sidebands not around signal.!!!!");
      return;
   }

   // Control variable range check - if control variable range is zero, fail
   if (fMaxXCont-fMinXCont==0){
      Error("DoFit", "Error: Control variable range must be provided.");
      return;
   }

   // Subtraction range check - if subtraction range is zero, fail
   if (fSubMax-fSubMin==0){
      Error("DoFit", "Error: Subtraction range must be provided.");
      return;
   }

   //// Draw strings
   TString drawCommandDisc = "";
   TString drawTitleDisc = "Discriminating variable: ";

   TString drawCommandCont = "";
   TString drawTitleCont = "Control variable: ";

   drawCommandDisc = TString::Format("%s>>hist1(%d,%f,%f)", branchNameDisc.c_str(), fBinsDisc, fMinXDisc, fMaxXDisc);
   drawTitleDisc += branchNameDisc.c_str();

   drawCommandCont = TString::Format("%s>>hist2(%d,%f,%f)", branchNameCont.c_str(), fBinsCont, fMinXCont, fMaxXCont);
   drawTitleCont += branchNameCont.c_str();

   TString drawCondition = "";

   // Apply condition 1
   Int_t Con1Index = fCon1ComboBox->GetSelected();
   if (Con1Index > 0) {
      TBranch *Con1Branch = (TBranch*)fTree->GetListOfBranches()->At(Con1Index - 1);
      Double_t Con1Min = fCon1MinInput->GetNumber();
      Double_t Con1Max = fCon1MaxInput->GetNumber();
      drawCondition += Form("%s > %.10g && %s < %.10g", Con1Branch->GetName(), Con1Min, Con1Branch->GetName(), Con1Max);
      drawTitleCont += Form(", %s[%.10g,%.10g]",Con1Branch->GetName(), Con1Min, Con1Max);  
   }

   // Output print
   std::cout << "////////  Drawn with following  ////////" << std::endl;
   std::cout << "Discriminating variable: " << drawCommandDisc.Data() << std::endl;
   std::cout << "Control variable: " << drawCommandCont.Data() << std::endl;
   std::cout << "Conditions: " << drawCondition.Data() << std::endl;

   //// Fitting
   // Define histograms
   fTree->Draw(drawCommandDisc.Data());
   TH1F *histDisc = (TH1F*)gDirectory->Get("hist1");
   fTree->Draw(drawCommandCont.Data(),drawCondition);
   TH1F *histCont = (TH1F*)gDirectory->Get("hist2");
   // Define fit functions 
   TF1 *fitFcn = nullptr;
   TF1 *SIGfit = nullptr;
   TF1 *BGfit = nullptr;
   // Autofit (Welcome!)
   if (autofit_check==1){
      cout << "Autofit engaged" << endl;
      // Set fit range equal to draw range
      fFitMin = fMinXDisc;
      fFitMax = fMaxXDisc;
      // Fit function
      fitFcn = new TF1("fitFcn",fitFunction,fFitMin,fFitMax,6);
      double discRange = fMaxXDisc-fMinXDisc;
      cout << "Disc range: " << discRange << endl;
      double mean = discRange/2;
      cout << "Mean: " << mean << endl;
      double std = mean/10;
      cout << "Standard deviation: " << std << endl;
      fitFcn->SetParameters(1,1,0.1,500,mean,std);
      fitFcn->SetLineColor(kViolet);
      histDisc->Fit("fitFcn","R+");
      /*/ Diagnose fit function
      double chi2_red = fitFcn->GetChisquare()/fitFcn->GetNDF();
      if (chi2_red>3) {
         std::cout << "Errot: Fit failed (reduced chi2 is greater than three).\nTry changing discriminating variable range." << std::endl;
         return;
      }*/
      // Signal fit function
      SIGfit = new TF1("SIGfit","[0]*TMath::Gaus(x,[1],[2])",fFitMin,fFitMax);
      SIGfit->SetParameter(0,fitFcn->GetParameter(3));
      SIGfit->SetParameter(1,fitFcn->GetParameter(4));
      SIGfit->SetParameter(2,fitFcn->GetParameter(5));
      // Background fit function
      BGfit = new TF1("BGfit","[0]+[1]*x+[2]*x**2",fFitMin,fFitMax);
      BGfit->SetParameter(0,fitFcn->GetParameter(0));
      BGfit->SetParameter(1,fitFcn->GetParameter(1));
      BGfit->SetParameter(2,fitFcn->GetParameter(2));
      // Define signal region
      int std_num = std::floor(discRange/(abs(fitFcn->GetParameter(5)))); // number of standard deviations in disc range
      int std_per_reg = std::floor(std_num/3); // number of standard deviations allowed per signal, sideband regions
      if (std_per_reg>3){
         std_per_reg=3;
      }
      fSigMin = abs(fitFcn->GetParameter(4))-((std_per_reg*abs(fitFcn->GetParameter(5))));
      fSigMax = abs(fitFcn->GetParameter(4))+((std_per_reg*abs(fitFcn->GetParameter(5))));
      // Define sideband regions
      fLSBMin = fSigMin-((std_per_reg+0.5)*abs(fitFcn->GetParameter(5)));
      if (fLSBMin<fMinXDisc){
         fLSBMin=fMinXDisc;
      }
      fLSBMax = fSigMin-(0.5*abs(fitFcn->GetParameter(5)));
      fRSBMin = fSigMax+(0.5*abs(fitFcn->GetParameter(5)));
      fRSBMax = fSigMax+((std_per_reg+0.5)*abs(fitFcn->GetParameter(5)));
      if (fRSBMax>fMaxXDisc){
         fRSBMax=fMaxXDisc;
      }

      //cout << "std_num: " << std_num << endl;
      ///cout << "std_per_reg: " << std_per_reg << endl;

      cout << "fFitMinInput: " << fFitMin<< endl;
      cout << "fFitMaxInput: " << fFitMax<< endl;
      cout << "fSigMinInput: " << fSigMin << endl;
      cout << "fSigMaxInput: " << fSigMax << endl;
      cout << "fLSBMinInput: " << fLSBMin<< endl;
      cout << "fLSBMaxInput: " << fLSBMax<< endl;
      cout << "fRSBMinInput: " << fRSBMin<< endl;
      cout << "fRSBMaxInput: " << fRSBMax<< endl;

      fFitMinInput->SetNumber(fFitMin);
      fFitMaxInput->SetNumber(fFitMax);
      fSigMinInput->SetNumber(fSigMin > 0.1 ? std::round(fSigMin * 1000.0) / 1000.0 : fSigMin);
      fSigMaxInput->SetNumber(fSigMax > 0.1 ? std::round(fSigMax * 1000.0) / 1000.0 : fSigMax);
      fLSBMinInput->SetNumber(fLSBMin > 0.1 ? std::round(fLSBMin * 1000.0) / 1000.0 : fLSBMin);
      fLSBMaxInput->SetNumber(fLSBMax > 0.1 ? std::round(fLSBMax * 1000.0) / 1000.0 : fLSBMax);
      fRSBMinInput->SetNumber(fRSBMin > 0.1 ? std::round(fRSBMin * 1000.0) / 1000.0 : fRSBMin);
      fRSBMaxInput->SetNumber(fRSBMax > 0.1 ? std::round(fRSBMax * 1000.0) / 1000.0 : fRSBMax);

   } else{  
      // User-inputted fit
      // Fit function
      fitFcn = new TF1("fitFcn",fitFunction,fFitMin,fFitMax,6);
      double mean = (fFitMax-fFitMin)/2;
      double std = mean/10;
      fitFcn->SetParameters(1,1,0.1,500,mean,std);
      fitFcn->SetLineColor(kViolet);
      histDisc->Fit("fitFcn","R+");
      /*/ Diagnose fit function
      double chi2_red = fitFcn->GetChisquare()/fitFcn->GetNDF();
      if (chi2_red>3) {
         std::cout << "Errot: Fit failed (reduced chi2 is greater than three).\nTry changing discriminating variable range." << std::endl;
         return;
      }*/
      // Signal fit function
      SIGfit = new TF1("SIGfit","[0]*TMath::Gaus(x,[1],[2])",fFitMin,fFitMax);
      SIGfit->SetParameter(0,fitFcn->GetParameter(3));
      SIGfit->SetParameter(1,fitFcn->GetParameter(4));
      SIGfit->SetParameter(2,fitFcn->GetParameter(5));
      // Background fit function
      BGfit = new TF1("BGfit","[0]+[1]*x+[2]*x**2",fFitMin,fFitMax);
      BGfit->SetParameter(0,fitFcn->GetParameter(0));
      BGfit->SetParameter(1,fitFcn->GetParameter(1));
      BGfit->SetParameter(2,fitFcn->GetParameter(2));
      // Weight computation
      double SIG_Int = BGfit->Integral(fSigMin,fSigMax);
      double LSB_Int = BGfit->Integral(fLSBMin,fLSBMax);
      double RSB_Int = BGfit->Integral(fRSBMin,fRSBMax);
      double sig_wgt = SIG_Int/(LSB_Int+RSB_Int);
   }

   //// Drawing
   // Clear each pad before drawing new histograms
   fCanvas->Clear();
   fCanvas->Divide(2, 1);
   // Pad 1
   fCanvas->cd(1);
   gPad->Clear();
   histDisc->SetTitle(drawTitleDisc.Data());
   histDisc->SetStats(0);
   histDisc->Draw();
   // Patterned histograms
   TH1* histDisc_cln1 = (TH1*)histDisc->Clone();
   histDisc_cln1->GetXaxis()->SetRangeUser(fLSBMin,fLSBMax);
   histDisc_cln1->SetFillColor(kAzure+7);
   histDisc_cln1->SetFillStyle(3354);
   TH1* histDisc_cln2 = (TH1*)histDisc->Clone();
   histDisc_cln2->GetXaxis()->SetRangeUser(fRSBMin,fRSBMax);
   histDisc_cln2->SetFillColor(kAzure+7);
   histDisc_cln2->SetFillStyle(3354);
   TH1* histDisc_cln3 = (TH1*)histDisc->Clone();
   histDisc_cln3->GetXaxis()->SetRangeUser(fSigMin,fSigMax);
   histDisc_cln3->SetFillColor(kOrange-3);
   histDisc_cln3->SetFillStyle(3354);
   // Draw patterned histograms
   histDisc_cln1->DrawCopy("same");
   histDisc_cln2->DrawCopy("same");
   histDisc_cln3->DrawCopy("same");
   // histDisc
   histDisc->DrawCopy("same");
   // Total fit function
   fitFcn->DrawCopy("same");
   fitFcn->SetLineColor(kViolet);
   // Signal fit function
   SIGfit->SetLineColor(kRed);
   SIGfit->DrawCopy("same");
   // Background fit function
   BGfit->SetLineColor(kBlue);
   BGfit->DrawCopy("same");
   histDisc->SetMinimum(0);
   // Signal fit info box
   TString SIGfit_str = Form("#splitline{Signal fit info}{#splitline{#mu: %.5g}{#sigma: %.5g}}", abs(fitFcn->GetParameter(4)), abs(fitFcn->GetParameter(5)));
   TPaveText* SIGfit_txt = new TPaveText(.7,.8,.9,.9,"brNDC");
   SIGfit_txt->SetFillColor(0);
   SIGfit_txt->SetBorderSize(1);
   SIGfit_txt->SetTextSize(0.025);
   SIGfit_txt->AddText(SIGfit_str);
   SIGfit_txt->DrawClone("Same");
   // Pad 2
   fCanvas->cd(2);
   gPad->Clear();
   histCont->Draw("hist");
   TH1* histCont_cln = (TH1*)histCont->Clone();
   histCont_cln->GetXaxis()->SetRangeUser(fSubMin,fSubMax);
   histCont_cln->SetFillColor(kOrange-3);
   histCont_cln->SetFillStyle(3354);
   histCont_cln->DrawCopy("same");
   histCont->DrawCopy("same");
   histCont->SetTitle(drawTitleCont.Data());
   histCont->SetMinimum(0);
   histCont->GetXaxis()->SetRangeUser(fMinXCont,fMaxXCont);
   // Update the canvas to display the histograms
   fCanvas->Update();

}

void MyMainFrame::DoSub() {

   // Retrieve the selected branch from the first combo box (branch to draw)
   if (fSelectedBranchDisc == -1) {
      Error("DoSub", "Error: No discriminating variable selected.");
      return;
   }
   if (fSelectedBranchCont == -1) {
      Error("DoSub", "Error: No control variable selected.");
      return;
   }
   
   // Get the branch corresponding to the selected option
   TBranch *branchDisc = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchDisc - 1); // fSelectedBranchDisc is 1-based
   if (!branchDisc) {
      Error("DoSub", "Invalid selection.");
      return;
   }
   string branchNameDisc = branchDisc->GetName();   
   TBranch *branchCont = (TBranch*)fTree->GetListOfBranches()->At(fSelectedBranchCont - 1); // fSelectedBranchCont is 1-based
   if (!branchCont) {
      Error("DoSub", "Invalid selection.");
      return;
   }
   string branchNameCont = branchCont->GetName();

   // Retrieve the number of bins, min and max X values from the input boxes
   Int_t fBinsDisc = fBinsEntryDisc->GetNumber();
   Double_t fMinXDisc = fMinXEntryDisc->GetNumber();
   Double_t fMaxXDisc = fMaxXEntryDisc->GetNumber();
   Double_t fFitMin = fFitMinInput->GetNumber();
   Double_t fFitMax = fFitMaxInput->GetNumber();
   Double_t fSigMin = fSigMinInput->GetNumber();
   Double_t fSigMax = fSigMaxInput->GetNumber();
   Double_t fLSBMin = fLSBMinInput->GetNumber();
   Double_t fLSBMax = fLSBMaxInput->GetNumber();
   Double_t fRSBMin = fRSBMinInput->GetNumber();
   Double_t fRSBMax = fRSBMaxInput->GetNumber();

   Int_t fBinsCont = fBinsEntryCont->GetNumber();
   Double_t fMinXCont = fMinXEntryCont->GetNumber();
   Double_t fMaxXCont = fMaxXEntryCont->GetNumber();
   Double_t fSubMin = fSubMinInput->GetNumber();
   Double_t fSubMax = fSubMaxInput->GetNumber();

   // Introducting autofit, a function that fits the discriminating variable using the total (poly+gauss) fit function
   //                       for a given discriminating variable range (only requirement)
   // Autofit is activated when disc range given and all other variables are zero (using differences might not work in some cases)
   // Autofit fails when there no peaks or when two or more peaks are found.
   // Note: consider autofit button at some point

   int autofit_check = 0;

   //// Checks
   // Total failure check - if all variables or all differences zero, fail
   if (fMaxXDisc==0 && fMinXDisc==0 && fFitMax==0 && fFitMin==0 && fSigMax==0 && fSigMin==0 && fLSBMax==0 && fLSBMin==0 && fRSBMax==0 && fRSBMin==0){
      Error("DoSub", "Error: All variables are zero.\nChoose a discriminating variable range and fit to activate Autofit.");
      return;
   }
   if (fMaxXDisc-fMinXDisc==0 && fFitMax-fFitMin==0 && fSigMax-fSigMin==0 && fLSBMax-fLSBMin==0 && fRSBMax-fRSBMin==0){
      Error("DoSub", "Error: All ranges are zero.\nChoose a non-zero discriminating variable range and fit to activate Autofit.");
      return;
   }
   // Discriminating variable range check - if discriminating variable range is zero, fail
   if (fMaxXDisc-fMinXDisc==0){
      Error("DoSub", "Error: Discriminating variable range must be provided.");
         return;
   }
   // Autofit check - if discrimnating variable range is non-zero and all other variables are zero, activate autofit
   if (fMaxXDisc-fMinXDisc!=0 && fFitMax==0 && fFitMin==0 && fSigMax==0 && fSigMin==0 && fLSBMax==0 && fLSBMin==0 && fRSBMax==0 && fRSBMin==0){
      cout << "Autofit activated (discrimnating variable range provided and all other variables zero)." << endl;
      autofit_check++;
   }

   // User variable failure - if all variables are non-zero but at least one has a difference of zero, fail 
   if (fMaxXDisc-fMinXDisc!=0 && autofit_check==0){
      // Fit range check
      if (fFitMax-fFitMin==0) {
         Error("DoSub", "Error: Fit range is zero.");
         return;
      }
      // Signal region check
      if (fSigMax-fSigMin==0) {
         Error("DoSub", "Error: Signal region range is zero.");
         return;
      }
      // Left sideband check
      if (fLSBMax-fLSBMin==0) {
         Error("DoSub", "Error: Left sideband range is zero.");
         return;
      }
      // Right sideband check
      if (fRSBMax-fRSBMin==0) {
         Error("DoSub", "Error: Right sideband range is zero.");
         return;
      }
   }

   // Sideband-signal check - if sideband and signal overlap or if signal not between sidebands, fail
   if (fLSBMax>fSigMin || fRSBMin<fSigMax && autofit_check==0){
      Error("DoSub", "Error: Sideband-signal overlap or sidebands not around signal.");
      return;
   }

   // Control variable range check - if control variable range is zero, fail
   if (fMaxXCont-fMinXCont==0){
      Error("DoSub", "Error: Control variable range must be provided.");
      return;
   }

   // Subtraction range check - if subtraction range is zero, fail
   if (fSubMax-fSubMin==0){
      Error("DoSub", "Error: Subtraction range must be provided.");
      return;
   }

   //// Draw strings
   TString drawCommandDisc = "";
   TString drawTitleDisc = "Discriminating variable: ";

   TString drawCommandCont = "";
   TString drawTitleCont = "Control variable: ";

   drawCommandDisc = TString::Format("%s>>hist1(%d,%f,%f)", branchNameDisc.c_str(), fBinsDisc, fMinXDisc, fMaxXDisc);
   drawTitleDisc += branchNameDisc.c_str();

   drawCommandCont = TString::Format("%s>>hist2(%d,%f,%f)", branchNameCont.c_str(), fBinsCont, fMinXCont, fMaxXCont);
   drawTitleCont += branchNameCont.c_str();

   TString drawCondition = "";

   // Apply condition 1
   Int_t Con1Index = fCon1ComboBox->GetSelected();
   if (Con1Index > 0) {
      TBranch *Con1Branch = (TBranch*)fTree->GetListOfBranches()->At(Con1Index - 1);
      Double_t Con1Min = fCon1MinInput->GetNumber();
      Double_t Con1Max = fCon1MaxInput->GetNumber();
      drawCondition += Form("%s > %.10g && %s < %.10g", Con1Branch->GetName(), Con1Min, Con1Branch->GetName(), Con1Max);
      drawTitleCont += Form(", %s[%.10g,%.10g]",Con1Branch->GetName(), Con1Min, Con1Max);  
   }

   // Output print
   std::cout << "////////  Drawn with following  ////////" << std::endl;
   std::cout << "Discriminating variable: " << drawCommandDisc.Data() << std::endl;
   std::cout << "Control variable: " << drawCommandCont.Data() << std::endl;
   std::cout << "Conditions: " << drawCondition.Data() << std::endl;

   //// Fitting and sideband subtraction
   // Define fit functions and weight
   TF1 *fitFcn = nullptr;
   TF1 *SIGfit = nullptr;
   TF1 *BGfit = nullptr;
   double sig_wgt;
   // Define histograms
   fTree->Draw(drawCommandDisc.Data());
   TH1F *histDisc = (TH1F*)gDirectory->Get("hist1");
   fTree->Draw(drawCommandCont.Data(),drawCondition);
   TH1F *histCont = (TH1F*)gDirectory->Get("hist2");
   TH1F *histSIG = nullptr;
   TH1F *histSB = nullptr;
   // Autofit (Welcome!)
   if (autofit_check==1){
      cout << "Autofit engaged" << endl;
      // Set fit range equal to draw range
      fFitMin = fMinXDisc;
      fFitMax = fMaxXDisc;
      // Fit function
      fitFcn = new TF1("fitFcn",fitFunction,fFitMin,fFitMax,6);
      double discRange = fMaxXDisc-fMinXDisc;
      cout << "Disc range: " << discRange << endl;
      double mean = discRange/2;
      cout << "Mean: " << mean << endl;
      double std = mean/10;
      cout << "Standard deviation: " << std << endl;
      fitFcn->SetParameters(1,1,0.1,500,mean,std);
      fitFcn->SetLineColor(kViolet);
      histDisc->Fit("fitFcn","R+");
      /*/ Diagnose fit function
      double chi2_red = fitFcn->GetChisquare()/fitFcn->GetNDF();
      if (chi2_red>3) {
         std::cout << "Errot: Fit failed (reduced chi2 is greater than three).\nTry changing discriminating variable range." << std::endl;
         return;
      }*/
      // Signal fit function
      SIGfit = new TF1("SIGfit","[0]*TMath::Gaus(x,[1],[2])",fFitMin,fFitMax);
      SIGfit->SetParameter(0,fitFcn->GetParameter(3));
      SIGfit->SetParameter(1,fitFcn->GetParameter(4));
      SIGfit->SetParameter(2,fitFcn->GetParameter(5));
      // Background fit function
      BGfit = new TF1("BGfit","[0]+[1]*x+[2]*x**2",fFitMin,fFitMax);
      BGfit->SetParameter(0,fitFcn->GetParameter(0));
      BGfit->SetParameter(1,fitFcn->GetParameter(1));
      BGfit->SetParameter(2,fitFcn->GetParameter(2));
      // Define signal region
      int std_num = std::floor(discRange/(abs(fitFcn->GetParameter(5)))); // number of standard deviations in disc range
      int std_per_reg = std::floor(std_num/3); // number of standard deviations allowed per signal, sideband regions
      if (std_per_reg>3){
         std_per_reg=3;
      }
      fSigMin = abs(fitFcn->GetParameter(4))-((std_per_reg*abs(fitFcn->GetParameter(5))));
      fSigMax = abs(fitFcn->GetParameter(4))+((std_per_reg*abs(fitFcn->GetParameter(5))));
      // Define sideband regions
      fLSBMin = fSigMin-((std_per_reg+0.5)*abs(fitFcn->GetParameter(5)));
      if (fLSBMin<fMinXDisc){
         fLSBMin=fMinXDisc;
      }
      fLSBMax = fSigMin-(0.5*abs(fitFcn->GetParameter(5)));
      fRSBMin = fSigMax+(0.5*abs(fitFcn->GetParameter(5)));
      fRSBMax = fSigMax+((std_per_reg+0.5)*abs(fitFcn->GetParameter(5)));
      if (fRSBMax>fMaxXDisc){
         fRSBMax=fMaxXDisc;
      }
      if (fLSBMax>fSigMin || fRSBMin<fSigMax && autofit_check==0){
         Error("DoSub", "Error: Sideband-signal overlap or sidebands not around signal!!!!!.");
         return;
      }
      fSigMinInput->SetNumber(fSigMin);
      fSigMaxInput->SetNumber(fSigMax);
      fFitMinInput->SetNumber(fFitMin);
      fFitMaxInput->SetNumber(fFitMax);
      fLSBMinInput->SetNumber(fLSBMin);
      fLSBMaxInput->SetNumber(fLSBMax);
      fRSBMinInput->SetNumber(fRSBMin);
      fRSBMaxInput->SetNumber(fRSBMax);
//// last here - considering conditions
      // Define histograms
      TString drawCommandSIG = TString::Format("%s>>histSIG(%d,%f,%f)", branchNameCont.c_str(), fBinsCont,fSubMin,fSubMax); 
      TString SIGcond = Form("%s>%.10g && %s<%.10g",branchNameDisc.c_str(),fSigMin,branchNameDisc.c_str(),fSigMax);
      TString drawCommandBG = TString::Format("%s>>histSB(%d,%f,%f)", branchNameCont.c_str(), fBinsCont,fSubMin,fSubMax);
      TString BGcond = Form("%s>%.10g && %s<%.10g || %s>%.10g && %s<%.10g",branchNameDisc.c_str(),fLSBMin,branchNameDisc.c_str(),fLSBMax,branchNameDisc.c_str(),fRSBMin,branchNameDisc.c_str(),fRSBMax);
      fTree->Draw(drawCommandSIG,SIGcond);
      histSIG = (TH1F*)gDirectory->Get("histSIG");
      fTree->Draw(drawCommandBG,BGcond);
      histSB = (TH1F*)gDirectory->Get("histSB");
      // Weight computation
      double SIG_Int = BGfit->Integral(fSigMin,fSigMax);
      double LSB_Int = BGfit->Integral(fLSBMin,fLSBMax);
      double RSB_Int = BGfit->Integral(fRSBMin,fRSBMax);
      sig_wgt = SIG_Int/(LSB_Int+RSB_Int);
   } else{
      // User-inputted fit
      // Fit function
      fitFcn = new TF1("fitFcn",fitFunction,fFitMin,fFitMax,6);
      double mean = (fFitMax-fFitMin)/2;
      double std = mean/10;
      fitFcn->SetParameters(1,1,0.1,500,mean,std);
      fitFcn->SetLineColor(kViolet);
      histDisc->Fit("fitFcn","R+");
      /*/ Diagnose fit function
      double chi2_red = fitFcn->GetChisquare()/fitFcn->GetNDF();
      if (chi2_red>3) {
         std::cout << "Errot: Fit failed (reduced chi2 is greater than three).\nTry changing discriminating variable range." << std::endl;
         return;
      }*/
      // Signal fit function
      SIGfit = new TF1("SIGfit","[0]*TMath::Gaus(x,[1],[2])",fFitMin,fFitMax);
      SIGfit->SetParameter(0,fitFcn->GetParameter(3));
      SIGfit->SetParameter(1,fitFcn->GetParameter(4));
      SIGfit->SetParameter(2,fitFcn->GetParameter(5));
      // Background fit function
      BGfit = new TF1("BGfit","[0]+[1]*x+[2]*x**2",fFitMin,fFitMax);
      BGfit->SetParameter(0,fitFcn->GetParameter(0));
      BGfit->SetParameter(1,fitFcn->GetParameter(1));
      BGfit->SetParameter(2,fitFcn->GetParameter(2));
      // Define histograms
      TString drawCommandSIG = TString::Format("%s>>histSIG(%d,%f,%f)", branchNameCont.c_str(), fBinsCont,fSubMin,fSubMax); 
      TString SIGcond = Form("%s>%.10g && %s<%.10g",branchNameDisc.c_str(),fSigMin,branchNameDisc.c_str(),fSigMax);
      TString drawCommandBG = TString::Format("%s>>histSB(%d,%f,%f)", branchNameCont.c_str(), fBinsCont,fSubMin,fSubMax);
      TString BGcond = Form("%s>%.10g && %s<%.10g || %s>%.10g && %s<%.10g",branchNameDisc.c_str(),fLSBMin,branchNameDisc.c_str(),fLSBMax,branchNameDisc.c_str(),fRSBMin,branchNameDisc.c_str(),fRSBMax);
      fTree->Draw(drawCommandSIG,SIGcond);
      histSIG = (TH1F*)gDirectory->Get("histSIG");
      fTree->Draw(drawCommandBG,BGcond);
      histSB = (TH1F*)gDirectory->Get("histSB");
      // Weight computation
      double SIG_Int = BGfit->Integral(fSigMin,fSigMax);
      double LSB_Int = BGfit->Integral(fLSBMin,fLSBMax);
      double RSB_Int = BGfit->Integral(fRSBMin,fRSBMax);
      sig_wgt = SIG_Int/(LSB_Int+RSB_Int);
   }

   //// Drawing
   // Clear each pad before drawing new histograms
   fCanvas->Clear();
   fCanvas->Divide(2, 1);   
   // Pad 1
   fCanvas->cd(1);
   gPad->Clear();
   histDisc->SetTitle(drawTitleDisc.Data());
   histDisc->SetStats(0);
   histDisc->Draw();
   // Patterned histograms
   TH1* histDisc_cln1 = (TH1*)histDisc->Clone();
   histDisc_cln1->GetXaxis()->SetRangeUser(fLSBMin,fLSBMax);
   histDisc_cln1->SetFillColor(kAzure+7);
   histDisc_cln1->SetFillStyle(3354);
   TH1* histDisc_cln2 = (TH1*)histDisc->Clone();
   histDisc_cln2->GetXaxis()->SetRangeUser(fRSBMin,fRSBMax);
   histDisc_cln2->SetFillColor(kAzure+7);
   histDisc_cln2->SetFillStyle(3354);
   TH1* histDisc_cln3 = (TH1*)histDisc->Clone();
   histDisc_cln3->GetXaxis()->SetRangeUser(fSigMin,fSigMax);
   histDisc_cln3->SetFillColor(kOrange-3);
   histDisc_cln3->SetFillStyle(3354);
   // Draw patterned histograms
   histDisc_cln1->DrawCopy("same");
   histDisc_cln2->DrawCopy("same");
   histDisc_cln3->DrawCopy("same");
   // histDisc
   histDisc->DrawCopy("same");
   // Total fit function
   fitFcn->DrawCopy("same");
   fitFcn->SetLineColor(kViolet);
   // Signal fit function
   SIGfit->SetLineColor(kRed);
   SIGfit->DrawCopy("same");
   // Background fit function
   BGfit->SetLineColor(kBlue);
   BGfit->DrawCopy("same");
   histDisc->SetMinimum(0);
   // Signal fit info box
   TString SIGfit_str = Form("#splitline{Signal fit info}{#splitline{#mu: %.5g}{#sigma: %.5g}}", abs(fitFcn->GetParameter(4)), abs(fitFcn->GetParameter(5)));
   TPaveText* SIGfit_txt = new TPaveText(.7,.8,.9,.9,"brNDC");
   SIGfit_txt->SetFillColor(0);
   SIGfit_txt->SetBorderSize(1);
   SIGfit_txt->SetTextSize(0.025);
   SIGfit_txt->AddText(SIGfit_str);
   SIGfit_txt->DrawClone("Same");
   // Pad 2
   fCanvas->cd(2);
   gPad->Clear();
   // Empty histogram with control variable range
   //histCont->Draw("hist");
   // Sideband subtraction
   histSIG->Add(histSB,-sig_wgt);
   histSIG->Draw("hist");
   histSIG->GetXaxis()->SetRangeUser(fMinXCont,fMaxXCont);
   histSIG->SetTitle(drawTitleCont.Data());
   gPad->Modified();
   gPad->Update();
   // Update the canvas to display the histograms
   fCanvas->Update();

}

void MyMainFrame::OnSelectDisc(Int_t id) {
   fSelectedBranchDisc = id;

}

void MyMainFrame::OnSelectCont(Int_t id) {
   fSelectedBranchCont = id;
}


MyMainFrame::~MyMainFrame() {
   // Clean up used widgets: frames, buttons, layout hints
   fMain->Cleanup();
   delete fMain;
   if (fFile1) {
      fFile1->Close();
      delete fFile1;
   }
}

void sbSubConsGUI(const char* filename1) {
   // Popup the GUI with the given ROOT file...
   new MyMainFrame(gClient->GetRoot(), 1400, 700, filename1);
}

